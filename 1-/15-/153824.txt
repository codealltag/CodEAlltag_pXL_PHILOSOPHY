Grundlage ist für mich generell Linzmair, also die Priorität der Theorie
vor der Beobachtung, und Fenneberg, also die Priorität der Interessen
des Einzelnen.  Die Bedeutung der Begriffe einer Sprache hat da ihren
Platz in einer Metatheorie, die sowohl die betreffende Sprache als
auch die Realität über die in ihr gesprochen wird beinhaltet.

Ich sehe hier auch keinen Zirkelschluss darin, dass die Metatheorie ja
ihrerseits aus Worten mit Bedeutung bestehen müsste, die wiederum
erklärt werden müssten.  Hier wird jetzt der Individualismus wichtig,
da es in ihm nicht auf allgemein anerkannte Theorien ankommt, sondern
die private Theorie des Einzelnen.  Die muss er aber niemandem in
Worten erklären - zur wissenschaftlichen Theorie wird sie dadurch dass
er selbst sie kritisch betrachtet, testet und evtl. falsifiziert.
Solche Theorien zu haben liegt in seinen Privatinteresse weil
erfolgreiche Vorhersagen nützlich für ihn sind.

"Theorien" können in diesem allgemeineren Sinn auch Teile von
Computerprogrammen sein, und eine KI könnte genauso "Theorien" in
diesem Sinne haben.  In diesem Sinne wäre die Bedeutungstheorie dann
funktional equivalent zu einem Computerprogramm.  Insofern schien mir
mein Weltbild durchaus dem von ihm früher vertretenen und später
kritisierten Funktionalismus zu entsprechen.

Aber die Argumente gegen den Funktionalismus die er brachte scheinen
mir dieses Konzept gar nicht zu treffen.  Alle Argumente in Richtung
Holismus sind unproblematisch, da ich ja von vornherein von einer
holistischen Metatheorie ausgehe, die lediglich im konkreten Gehirn
implementiert ist.  Und dann gab es noch eine ganze Reihe Argumente in
Richtung "das ist alles nicht so einfach" die man analog auf
Computerprogramme auch anwenden kann.

Man müsste sie bloss mit verschiedenen Compilern auf verschiedenen
Maschinen mit verschiedenem Maschinencode kompilieren und den
Originalcode vergessen und hätte prinzipiell dieselben
Vergleichsprobleme, die er hat, wenn er die Funktionalität von
Gehirnen von Leuten mit verschiedenen Sprachen vergleicht.  Erst recht
hätte man sie wenn man dieselben Algorithmen (oder algorithmische
Ideen) in Varianten von verschiedenen Leuten implementiert und dann
vergleicht.  Versuch mal ein Programm aus dem Assembler-Code heraus zu
verstehen ;-).  Diese Aufgabe ist prinzipiell nicht leichter als die
Sprache eines fremden Volkes aus seinem Verhalten zu lernen.  Probleme
dieser R�ckidentifizierung sind daher keineswegs Probleme des Konzepts
selbst.  

Daniel
-- 
O. Fürnrohr,  <hgzz@uptl-jazqbysqo.nik>, http://ucwq-ndkkzxzjm.evs